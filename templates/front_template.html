<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
        <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
        <script>
          tailwind.config = {
            theme: {
              extend: {
                fontFamily: {
                  sans: ['Inter', 'ui-sans-serif', 'system-ui'],
                }
              }
            }
          }
        </script>
        <link rel="stylesheet" href="./static/style.css">
        <title>{{TITLE}}</title>
    </head>
    <body class="bg-white text-slate-900">
        <div class="mx-auto max-w-4xl px-4 sm:px-6 lg:px-8 py-12 font-sans">
            {{BODY}}
        </div>
        <div class="flex justify-center lg:justify-end mt-10 mb-4 px-4 sm:px-6 lg:px-8 theme-toggle-container">
            <button id="theme-toggle" type="button" class="theme-toggle" aria-label="Toggle dark mode">
                <span id="theme-toggle-icon" aria-hidden="true">☾</span>
                <span id="theme-toggle-text">Dark</span>
            </button>
        </div>
        <script>
          document.addEventListener('DOMContentLoaded', () => {
            const themeToggle = document.getElementById('theme-toggle');
            const themeIcon = document.getElementById('theme-toggle-icon');
            const themeText = document.getElementById('theme-toggle-text');

            const getPreferredTheme = () => {
              const stored = localStorage.getItem('theme');
              if (stored === 'dark' || stored === 'light') return stored;
              return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            };

            const applyTheme = (mode, persist = false) => {
              const isDark = mode === 'dark';
              document.body.classList.toggle('dark', isDark);
              if (themeIcon) themeIcon.textContent = isDark ? '☀' : '☾';
              if (themeText) themeText.textContent = isDark ? 'Light' : 'Dark';
              if (persist) {
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
              }
            };

            applyTheme(getPreferredTheme());
            if (themeToggle) {
              themeToggle.addEventListener('click', () => {
                const next = document.body.classList.contains('dark') ? 'light' : 'dark';
                applyTheme(next, true);
              });
            }

            const portrait = document.getElementById('me');
            if (!portrait) return;

            const clickWindowMs = 1000;
            let clickTimes = [];
            let bouncing = false;

            const handlePortraitClick = () => {
              triggerPulse();

              if (bouncing) {
                window.open('https://www.youtube.com/watch?time_continue=1&v=QOtuX0jL85Y&embeds_referring_euri=https%3A%2F%2Fwww.google.com%2Fsearch%3Fclient%3Dsafari%26rls%3Den%26q%3Dyoutube%2Boffice%2Bdvd%2Bbounce%26ie%3DUTF-8%26oe%3DUTF-8&source_ve_path=Mjg2NjY', '_blank', 'noopener,noreferrer');
                return;
              }

              const now = Date.now();
              clickTimes = clickTimes.filter((t) => now - t < clickWindowMs);
              clickTimes.push(now);

              if (clickTimes.length >= 2 && !bouncing) {
                // Easter egg: bounce the portrait like a DVD logo.
                startBounce();
              }
            };

            portrait.addEventListener('click', handlePortraitClick);
            portrait.addEventListener('contextmenu', (event) => {
              event.preventDefault();
              handlePortraitClick();
            });

            function startBounce() {
              bouncing = true;
              const rect = portrait.getBoundingClientRect();
              const portraitWidth = rect.width;
              const portraitHeight = rect.height;

              const placeholder = document.createElement('div');
              const computed = getComputedStyle(portrait);
              placeholder.style.width = `${portraitWidth}px`;
              placeholder.style.height = `${portraitHeight}px`;
              placeholder.style.display = computed.display === 'inline' ? 'inline-block' : computed.display;
              placeholder.style.margin = computed.margin;
              placeholder.style.visibility = 'hidden';
              placeholder.setAttribute('aria-hidden', 'true');
              portrait.parentNode.insertBefore(placeholder, portrait);

              portrait.style.position = 'fixed';
              portrait.style.left = `${rect.left}px`;
              portrait.style.top = `${rect.top}px`;
              portrait.style.width = `${portraitWidth}px`;
              portrait.style.margin = '0';
              portrait.style.zIndex = '9999';

              let x = rect.left;
              let y = rect.top;
              let vx = (Math.random() * 120 + 80) * (Math.random() < 0.5 ? -1 : 1);
              let vy = (Math.random() * 120 + 80) * (Math.random() < 0.5 ? -1 : 1);
              let last = performance.now();

              const step = (now) => {
                const dt = (now - last) / 1000;
                last = now;

                x += vx * dt;
                y += vy * dt;

                const maxX = window.innerWidth - portraitWidth;
                const maxY = window.innerHeight - portraitHeight;

                if (x <= 0) {
                  x = 0;
                  vx = Math.abs(vx);
                } else if (x >= maxX) {
                  x = maxX;
                  vx = -Math.abs(vx);
                }

                if (y <= 0) {
                  y = 0;
                  vy = Math.abs(vy);
                } else if (y >= maxY) {
                  y = maxY;
                  vy = -Math.abs(vy);
                }

                portrait.style.left = `${x}px`;
                portrait.style.top = `${y}px`;

                requestAnimationFrame(step);
              };

              requestAnimationFrame(step);

              window.addEventListener('resize', () => {
                const maxX = window.innerWidth - portraitWidth;
                const maxY = window.innerHeight - portraitHeight;
                x = Math.min(Math.max(x, 0), maxX);
                y = Math.min(Math.max(y, 0), maxY);
                portrait.style.left = `${x}px`;
                portrait.style.top = `${y}px`;
              });
            }

            function triggerPulse() {
              portrait.classList.remove('portrait-pulse');
              // Force reflow so the animation restarts on rapid clicks.
              void portrait.offsetWidth;
              portrait.classList.add('portrait-pulse');
            }
          });
        </script>
    </body>
</html>
